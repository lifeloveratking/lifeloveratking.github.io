<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林</title>
  
  <subtitle>-de xiaowu</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-17T08:29:25.879Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>miiiss</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swagger</title>
    <link href="http://example.com/2023/04/17/swagger/"/>
    <id>http://example.com/2023/04/17/swagger/</id>
    <published>2023-04-17T03:07:21.000Z</published>
    <updated>2023-04-17T08:29:25.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="swagger"><a href="#swagger" class="headerlink" title="swagger"></a>swagger</h1><p>学习目标</p><ol><li>了解swagger的作用和概念</li><li>了解前后端分离</li><li>在springboot集成swagger</li></ol><p>Swagger简介</p><p><strong>前后端分离</strong></p><p>Vue+spring boot</p><p>后端时代：前端只用管理静态页面；html&#x3D;&#x3D;》后端。模版引擎：jsp&#x3D;&#x3D;》后端是主力</p><p>前后端分离时代：</p><ul><li>后端：后端控制层：controller，service，dao【后端团队】</li><li>前端： 前端控制层，视图层 【前端团队】<ul><li>伪造后端数据，json</li></ul></li><li>前后端如何交互？&#x3D;&#x3D;》api</li><li>前后端相互独立</li><li>前后端相对独立</li><li>前后端可以布置到不同服务器</li></ul><p>产生一个问题</p><ul><li>前后端集成联调，前后端无法做到“几时联动，尽早解决”最终导致问题集中爆发；解决方案。</li><li>首先指定schema【计划的提纲】，实时更新最新的api。降低继承的风险。</li><li>早些年：指定word的计划文档</li><li>前后端分离<ul><li>前端测试后端测试：postman</li><li>后端提供接口：需要实时更新及改动</li></ul></li></ul><p>Swagger</p><ul><li>号称世界上最流行的api框架</li><li>restful api文档自动生成工具-api与api定义同时更新</li><li>直接运行</li></ul><p>在项目中使用swagger需要springbox：</p><ul><li>swagger2</li><li>ui</li></ul><h2 id="springboot集成swagger"><a href="#springboot集成swagger" class="headerlink" title="springboot集成swagger"></a>springboot集成swagger</h2><ol><li><p>新建一个spring boot-web项目</p></li><li><p>导入依赖</p><!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --><dependency>    <groupId>io.springfox</groupId>    <artifactId>springfox-swagger2</artifactId>    <version>2.9.1</version></dependency><!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --><dependency>    <groupId>io.springfox</groupId>    <artifactId>springfox-swagger-ui</artifactId>    <version>2.9.2</version></dependency></li><li><p>编写一个hello工程</p></li><li><p>配置swagger</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lin.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里主要为了解决跨域问题,所以重写addCorsMappings方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;access-control-allow-headers&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;access-control-allow-methods&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;access-control-allow-origin&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;access-control-max-age&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;X-Frame-Options&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">false</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line">        <span class="built_in">super</span>.addCorsMappings(registry);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//解决swagger映射</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>).addResourceLocations(</span><br><span class="line">                <span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/swagger-ui.html&quot;</span>).addResourceLocations(</span><br><span class="line">                <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(</span><br><span class="line">                <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.addResourceHandlers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> 点击此页面出现这类error情况，是因为</p><blockquote><h2 id="swagger-ui-html-404问题解决"><a href="#swagger-ui-html-404问题解决" class="headerlink" title="swagger-ui.html 404问题解决"></a>swagger-ui.html 404问题解决</h2><p><a href="https://dev-tang.com/"> 唐际忠的博客 </a><em>2020-01-06 16:35:00</em></p><p><a href="data:image/png;base64,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"> 手机阅读 </a><a href="https://dev-tang.com/wechat_zan.jpg"> 微信赞赏</a></p><p>Spring boot整合swagger2（版本号：2.9.2）出现404错误。这个实在没啥说的直接上错误和解决方法。</p><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><p>页面出现这个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Whitelabel Error Page</span><br><span class="line">This application has no explicit mapping for /error, so you are seeing this as a fallback.</span><br><span class="line"></span><br><span class="line">Mon Jan 06 16:38:25 CST 2020</span><br><span class="line">There was an unexpected error (type=Not Found, status=404).</span><br><span class="line">No message available </span><br></pre></td></tr></table></figure><p>java控制台出现这样的日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o.s.web.servlet.DispatcherServlet - GET &quot;/swagger-ui.html&quot;, parameters=&#123;&#125;</span><br><span class="line">o.s.web.servlet.PageNotFound - No mapping for GET /swagger-ui.html</span><br><span class="line">o.s.web.servlet.DispatcherServlet - Completed 404 NOT_FOUND</span><br><span class="line">o.s.web.servlet.DispatcherServlet - &quot;ERROR&quot; dispatch for GET &quot;/error&quot;, parameters=&#123;&#125;</span><br><span class="line">o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)</span><br><span class="line">o.s.web.servlet.DispatcherServlet - Exiting from &quot;ERROR&quot; dispatch, status 404</span><br></pre></td></tr></table></figure><p>但是&#x2F;v2&#x2F;api-docs又是可以访问的。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>办法1、检查是否有地方加了这个注解<code>@EnableWebMvc</code>，有的话删掉就可以了。</p><p>办法2、检查是否有类继承了<code>WebMvcConfigurationSupport</code>，有的话删掉就可以了。</p><p>因为上面两个会覆盖spring mvc原本的配置，比如覆盖yml里面的配置。</p><p>办法3、另外一种解决办法，就是继承<code>WebMvcConfigurationSupport</code>后，重写下面的方法，重新配置静态资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line"> registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>).addResourceLocations(</span><br><span class="line">         <span class="string">&quot;classpath:/static/&quot;</span>);</span><br><span class="line"> registry.addResourceHandler(<span class="string">&quot;swagger-ui.html&quot;</span>).addResourceLocations(</span><br><span class="line">         <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line"> registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(</span><br><span class="line">         <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line"> <span class="built_in">super</span>.addResourceHandlers(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按上面三种方法排查，404错误基本可以得到解决了。 重新启动服务器，你会发现那个绿黄绿黄的swagger页面又出现了。</p><p>404错误github参考：<a href="https://github.com/springfox/springfox/issues/776">https://github.com/springfox/springfox/issues/776</a></p><h4 id="补充（2020-05-13）"><a href="#补充（2020-05-13）" class="headerlink" title="补充（2020-05-13）"></a>补充（2020-05-13）</h4><p>笔者正在做的一个项目，引入了springfox-swagger2后，按照上面三个步骤检测了，swagger-ui.html页面依然404，后来排查发现，springfox-swagger-ui这个包没有被依赖引入。 在pom.xml里面加上这个swagger ui的jar包引用就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>Swagger配置接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置了swagger的bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//RequestHandlerSelectors 指定要扫描的包</span></span><br><span class="line">                <span class="comment">//withMethodAnnotation:扫描方法上的注解</span></span><br><span class="line">                <span class="comment">// basePackage: 扫描指定的包</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.lin.controller&quot;</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//只能搜索到localhost；8080：/lin下面的</span></span><br><span class="line">                .paths(PathSelectors.ant(<span class="string">&quot;/lin/**&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我只希望我的swagger在生产环境中使用，在发布的时候不使用。</p><ul><li>判断是不是生产环境 flag&#x3D;false</li><li>注入enable</li></ul><p>配置api分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.groupName(&quot;lin y&quot;)</span><br></pre></td></tr></table></figure><p>如何配置多个分组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;swagger&quot;&gt;&lt;a href=&quot;#swagger&quot; class=&quot;headerlink&quot; title=&quot;swagger&quot;&gt;&lt;/a&gt;swagger&lt;/h1&gt;&lt;p&gt;学习目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;了解swagger的作用和概念&lt;/li&gt;
&lt;li&gt;了解前后端分离</summary>
      
    
    
    
    <category term="spring" scheme="http://example.com/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>spring技术详解</title>
    <link href="http://example.com/2023/04/16/spring1/"/>
    <id>http://example.com/2023/04/16/spring1/</id>
    <published>2023-04-16T04:39:15.000Z</published>
    <updated>2023-04-17T08:29:02.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring核心技术详解-一"><a href="#Spring核心技术详解-一" class="headerlink" title="Spring核心技术详解(一)"></a>Spring核心技术详解(一)</h1><p><a href="https://www.zhihu.com/people/tobetopjavaer"><img src="https://picx.zhimg.com/v2-3d74e4bbe6676c63522dbf5e29b0f81a_l.jpg?source=32738c0c" alt="java架构师"></a></p><p><a href="https://www.zhihu.com/people/tobetopjavaer">java架构师</a></p><p>35 人赞同了该文章</p><h2 id="一、Sring简介"><a href="#一、Sring简介" class="headerlink" title="一、Sring简介"></a>一、Sring简介</h2><p>Spring是一个分层的Java SE&#x2F;EE应用一站式的<code>轻量级开源框架</code>。Spring核心是<code>IOC</code>和<code>AOP</code>。 Spring主要优点包括：</p><ul><li><strong>方便解耦，简化开发，通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码造成的程序耦合度高。</strong></li><li><strong>AOP编程的支持，通过Spring提供的AOP功能，方便进行面向切面编程。</strong></li><li><strong>声明式事务的支持，在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</strong></li><li><strong>方便程序的测试，可以用非容器依赖的编程方式进行几乎所有的测试工作。</strong></li><li><strong>方便集成各种优秀框架，Spring提供了对各种优秀框架的直接支持。</strong></li></ul><h2 id="二、Spring体系结构"><a href="#二、Spring体系结构" class="headerlink" title="二、Spring体系结构"></a>二、Spring体系结构</h2><p>如下图所示，整个spring框架按其所属功能可以划分为五个主要模块，这五个模块几乎为企业应用提供了所需的一切，从持久层、业务层到表现层都拥有相应的支持，这就是为什么称Spring是一站式框架的原因。</p><p><img src="https://pic4.zhimg.com/80/v2-9c65f4004a1ed6727faa9f024ce8ba6b_720w.webp" alt="img"></p><h3 id="核心模块-Core-Container"><a href="#核心模块-Core-Container" class="headerlink" title="核心模块(Core Container)"></a>核心模块(Core Container)</h3><p>Spring的核心模块实现了IoC的功能，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述。由IoC容器负责类的创建，管理，获取等。BeanFactory接口是Spring框架的核心接口，实现了容器很多核心的功能。</p><p>Context模块构建于核心模块之上，扩展了BeanFactory的功能，包括国际化，资源加载，邮件服务，任务调度等多项功能。ApplicationContext是Context模块的核心接口。</p><p>表达式语言(Expression Language)是统一表达式语言(EL)的一个扩展，支持设置和获取对象属性，调用对象方法，操作数组、集合等。使用它可以很方便的通过表达式和Spring IoC容器进行交互。</p><h3 id="AOP模块"><a href="#AOP模块" class="headerlink" title="AOP模块"></a>AOP模块</h3><p>Spring AOP模块提供了满足AOP Alliance规范的实现，还整合了AspectJ这种AOP语言级的框架。通过AOP能降低耦合。</p><h3 id="数据访问集成模块（Data-Access-x2F-Integration-）"><a href="#数据访问集成模块（Data-Access-x2F-Integration-）" class="headerlink" title="数据访问集成模块（Data Access&#x2F;Integration ）"></a>数据访问集成模块（Data Access&#x2F;Integration ）</h3><p>该模块包括了JDBC、ORM、OXM、JMS和事务管理：</p><ul><li>事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。</li><li>JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</li><li>ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括hibernate、JPA、MyBatis等。而且可以使用Spring事务管理，无需额外控制事务。</li><li>OXM模块：提供了一个对Object&#x2F;XML映射实现，将Java对象映射成XML数据，或者将XML数据映射成java对象，Object&#x2F;XML映射实现包括JAXB、Castor、XMLBeans和XStream。</li><li>JMS模块：用于JMS(Java Messaging Service)，提供一套“消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li></ul><h3 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h3><p>该模块建立在ApplicationContext模块之上，提供了Web应用的功能，如文件上传、FreeMarker等。Spring可以整合Struts2等MVC框架。此外，Spring自己提供了MVC框架Spring MVC。</p><h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>Spring可以用非容器依赖的编程方式进行几乎所有的测试工作，支持JUnit和TestNG等测试框架。</p><h2 id="三、初识Ioc与DI"><a href="#三、初识Ioc与DI" class="headerlink" title="三、初识Ioc与DI"></a>三、初识Ioc与DI</h2><p>我们首先来讲解一下IoC的概念。IoC(控制反转:Inverse of Control)是Spring容器的核心，但是IoC这个概念却比较晦涩，让人不太容易望文生义。</p><h3 id="1、IoC控制反转和DI依赖注入"><a href="#1、IoC控制反转和DI依赖注入" class="headerlink" title="1、IoC控制反转和DI依赖注入"></a>1、IoC控制反转和DI依赖注入</h3><p>传统程序设计中，我们需要使用某个对象的方法，需要先通过new创建一个该对象，我们这时是主动行为；而IoC是我们将创建对象的控制权交给IoC容器，这时是由容器帮忙创建及注入依赖对象，我们的<code>程序被动的接受IoC容器创建的对象</code><br>，控制权反转，所以叫控制反转。</p><p>由于IoC确实不够开门见山，所以提出了DI（依赖注入：Dependency<br>Injection）的概念，即让第三方来实现注入，以移除我们类与需要使用的类之间的依赖关系。总的来说，IoC是目的，DI是手段，创建对象的过程往往意味着依赖的注入。我们为了实现IoC，让生成对象的方式由传统方式(new)<br>反转过来，需要创建相关对象时由IoC容器帮我们注入(DI)。</p><p>简单的说，就是我们类里需要另一个类，只需要让Spring帮我们创建 ，这叫做<code>控制反转</code>；然后Spring帮我们将需要的对象设置到我们的类中，这叫做<code>依赖注入</code>。</p><h3 id="2、常见的几种注入方法"><a href="#2、常见的几种注入方法" class="headerlink" title="2、常见的几种注入方法"></a>2、常见的几种注入方法</h3><ul><li><strong>使用有参构造方法注入</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;tom&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>使用属性注入</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">     user.setName(<span class="string">&quot;jack&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>使用接口注入</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将调用类所有依赖注入的方法抽取到接口中，调用类通过实现该接口提供相应的注入方法。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DapIml</span> <span class="keyword">implements</span> <span class="title class_">Dao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过容器完成依赖关系的注入</strong></p><p>上面的注入方式都需要我们手动的进行注入，如果有一个<code>第三方容器能帮助我们完成类的实例化</code><br>，以及依赖关系的装配，那么我们只需要专注于业务逻辑的开发即可。Spring就是这样的容器，它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。</p><h3 id="3、Spring的IoC例子"><a href="#3、Spring的IoC例子" class="headerlink" title="3、Spring的IoC例子"></a>3、Spring的IoC例子</h3><p>(1) 创建工程，导入jar包</p><p>这里我们只是做IoC的操作，所以只需要导入核心模块里的jar包，beans、core、context、expression等。因为spring中并没有日志相关的jar包，所以我们还需要导入log4j和commons-logging。</p><p>(2) 创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 创建一个xml配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">                        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置要创建的类  </span></span><br><span class="line">    &lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.cad.domain.User&quot;</span>/&gt;        </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>(4) 进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这只是用来测试的代码，后期不会这么写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        User user=(User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在容器启动时，Spring会根据配置文件的描述信息，自动实例化Bean并完成依赖关系的装配，从容器中即可获得Bean实例，就可以直接使用。Spring为什么仅凭一个简单的配置文件，就能神奇的实例化并配置好程序使用的Bean呢？答案是通过 <code>Java的反射技术</code><br>。</p><h3 id="4、Spring的DI例子"><a href="#4、Spring的DI例子" class="headerlink" title="4、Spring的DI例子"></a>4、Spring的DI例子</h3><p>我们的service层总是用到dao层，以前我们总是在Service层new出dao对象，现在我们使用依赖注入的方式向Service层注入dao层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserDao</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    UserDao userdao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserdao</span><span class="params">(UserDao userdao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userdao=userdao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service.......&quot;</span>);</span><br><span class="line">        userdao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------分割线--------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;userdao&quot;</span> class=<span class="string">&quot;com.cad.domain.UserDao&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line"><span class="comment">//这样在实例化service的时候，同时装配了dao对象，实现了依赖注入</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;userservice&quot;</span> class=<span class="string">&quot;com.cad.domain.UserService&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//ref为dao的id值</span></span><br><span class="line">    &lt;property name=<span class="string">&quot;userdao&quot;</span> ref=<span class="string">&quot;userdao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="四、Spring资源访问神器——Resource接口"><a href="#四、Spring资源访问神器——Resource接口" class="headerlink" title="四、Spring资源访问神器——Resource接口"></a>四、Spring资源访问神器——Resource接口</h2><p>JDK提供的访问资源的类(如java.NET.URL,File)等并不能很好很方便的满足各种底层资源的访问需求。Spring设计了一个Resource接口，为应用提供了更强的访问底层资源的能力，该接口拥有对应不同资源类型的实现类。</p><h3 id="1、Resource接口的主要方法"><a href="#1、Resource接口的主要方法" class="headerlink" title="1、Resource接口的主要方法"></a>1、Resource接口的主要方法</h3><ul><li>***boolean exists()***：资源是否存在</li><li>***boolean isOpen()***：资源是否打开</li><li>***URL getURL()***：返回对应资源的URL</li><li>***File getFile()***：返回对应的文件对象</li><li>***InputStream getInputStream()***：返回对应资源的输入流</li></ul><p>Resource在Spring框架中起着不可或缺的作用，Spring框架使用Resource装载各种资源，包括配置文件资源，国际化属性资源等。</p><h3 id="2、Resource接口的具体实现类"><a href="#2、Resource接口的具体实现类" class="headerlink" title="2、Resource接口的具体实现类"></a>2、Resource接口的具体实现类</h3><ul><li>***ByteArrayResource***：二进制数组表示的资源</li><li>***ClassPathResource***：类路径下的资源 ，资源以相对于类路径的方式表示</li><li>***FileSystemResource***：文件系统资源，资源以文件系统路径方式表示，如d:&#x2F;a&#x2F;b.txt</li><li>***InputStreamResource***：对应一个InputStream的资源</li><li>***ServletContextResource***：为访问容器上下文中的资源而设计的类。负责以相对于web应用根目录的路径加载资源</li><li>***UrlResource***：封装了java.net.URL。用户能够访问任何可以通过URL表示的资源，如Http资源，Ftp资源等</li></ul><h3 id="3、Spring的资源加载机制"><a href="#3、Spring的资源加载机制" class="headerlink" title="3、Spring的资源加载机制"></a>3、Spring的资源加载机制</h3><p>为了访问不同类型的资源，必须使用相应的Resource实现类，这是比较麻烦的。Spring提供了一个强大的加载资源的机制，仅通过资源地址的特殊标识就可以加载相应的资源。首先，我们了解一下Spring<code>支持哪些资源类型的地址前缀</code>:</p><ul><li>***classpath***：例如classpath:com&#x2F;cad&#x2F;domain&#x2F;bean.xml。从类路径中加载资源</li><li>***file***：例如 file:com&#x2F;cad&#x2F;domain&#x2F;bean.xml.使用UrlResource从文件系统目录中加载资源。</li><li>***http***：&#x2F;&#x2F;<br>例如<a href="https://link.zhihu.com/?target=http://www.baidu.com/resource/bean.xml">http://www.baidu.com/resource/bean.xml</a><br>使用UrlResource从web服务器加载资源</li><li>***ftp***：&#x2F;&#x2F; 例如frp:&#x2F;&#x2F;10.22.10.11&#x2F;bean.xml 使用UrlResource从ftp服务器加载资源</li></ul><p>Spring定义了一套资源加载的接口。ResourceLoader接口仅有一个getResource(String location)<br>的方法，可以根据资源地址加载文件资源。资源地址仅支持带资源类型前缀的地址，不支持Ant风格的资源路径表达式。ResourcePatternResolver扩展ResourceLoader接口，定义新的接口方法getResources(<br>String locationPattern)，该方法支持带资源类型前缀以及Ant风格的资源路径的表达式。PathMatchingResourcePatternResolver是Spring提供的标准实现类。</p><h3 id="4、例子"><a href="#4、例子" class="headerlink" title="4、例子"></a>4、例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ResourceLoader</span> <span class="variable">resloLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>();</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> resloLoader.getResource(<span class="string">&quot;https://www.baidu.com/&quot;</span>);</span><br><span class="line">        System.out.println(res <span class="keyword">instanceof</span> UrlResource); <span class="comment">// true</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(res.getInputStream()));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = bf.readLine())!= <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n-----------------------------\n&quot;</span>);</span><br><span class="line">        res = resloLoader.getResource(<span class="string">&quot;classpath:test.txt&quot;</span>);</span><br><span class="line">        bf = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(res.getInputStream()));</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        temp = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = bf.readLine())!= <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n-----------------------------\n&quot;</span>);</span><br><span class="line">        res = resloLoader.getResource(<span class="string">&quot;file:C:\\Users\\ricco\\Desktop\\test\\test.txt&quot;</span>);</span><br><span class="line">        bf = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(res.getInputStream()));</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        temp = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = bf.readLine())!= <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Spring的Ioc容器详解"><a href="#五、Spring的Ioc容器详解" class="headerlink" title="五、Spring的Ioc容器详解"></a>五、Spring的Ioc容器详解</h2><h3 id="1、BeanFactory"><a href="#1、BeanFactory" class="headerlink" title="1、BeanFactory"></a>1、BeanFactory</h3><p>BeanFactory是一个类工厂，和传统的类工厂不同，传统的类工厂仅负责构造一个类或几个类的实例；而BeanFactory可以创建并管理各种类的对象，Spring称这些被创建和管理的Java对象为Bean。</p><p>BeanFactory是一个接口，Spring为BeanFactory提供了多种实现，最常用的就是XmlBeanFactory。其中，BeanFactory接口最主要的方法就是getBean(String beanName)<br>，该方法从容器中返回指定名称的Bean。此外，BeanFactory接口的功能可以通过实现它的接口进行扩展(比如ApplicationContext)。看下面的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们使用Spring配置文件为User类提供配置信息，然后通过BeanFactory装载配置文件，启动Spring IoC容器。 </span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> class=<span class="string">&quot;com.cad.domain.User&quot;</span>&gt;&lt;/bean&gt;   </span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"><span class="comment">// 我们通过XmlBeanFactory实现类启动Spring IoC容器 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="comment">//获取配置文件</span></span><br><span class="line">        ResourcePatternResolver  resolver=<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>(); </span><br><span class="line">        Resource rs=resolver.getResource(<span class="string">&quot;classpath:bean.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载配置文件并启动IoC容器</span></span><br><span class="line">        BeanFactory bf=<span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从容器中获取Bean对象</span></span><br><span class="line">        User user=(User) bf.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        user.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XmlBeanFactory装载Spring配置文件并启动IoC容器，通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化创建动作在第一个调用时。在初始化BeanFactory，必须提供一种日志框架，我们使用Log4J。</p><h3 id="2、ApplicationContext"><a href="#2、ApplicationContext" class="headerlink" title="2、ApplicationContext"></a>2、ApplicationContext</h3><p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要编程方式来实现，而ApplicationContext中可以通过配置的方式来实现。ApplicationContext的主要实现类是<code>ClassPathXmlApplicationContext</code><br>和<code>FileSystemXmlApplicationContext</code>，前者默认从类路径加载配置文件，后者默认从文件系统中加载配置文件，如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 和BeanFactory初始化相似，ApplicationContext初始化也很简单</span><br><span class="line">ApplicationContext ac=new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br></pre></td></tr></table></figure><p>ApplicationContext的初始化和BeanFactory初始化有一个重大的区别，<code>BeanFactory初始化容器时并未初始化Bean，只有第一次访问Bean时才创建；而ApplicationContext则在初始化时就实例化所有的单实例的Bean</code><br>。因此，ApplicationContext的初始化时间会稍长一点。</p><h3 id="3、WebApplicationContext"><a href="#3、WebApplicationContext" class="headerlink" title="3、WebApplicationContext"></a>3、WebApplicationContext</h3><p>WebApplicationContext是专门为Web应用准备的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作。从WebApplicationContext中可以获取ServletContext的引用，整个WebApplicationContext对象作为属性放置到ServletContext中，以便Web应用环境中可以访问Spring应用上下文。<code>ConfigurableWebApplicationContext</code><br>扩展了WebApplicationContext,允许通过配置方式实例化WebApplicationContext，定义了两个重要方法。</p><ul><li>***setServletContext(ServletContext servletcontext)***：为Spring设置ServletContext</li><li>***setConfigLocation(String[] configLocations)***：设置Spring配置文件地址。</li></ul><p>WebApplicationContext<code>初始化的时机和方式</code><br>是：利用Spring提供的ContextLoaderListener监听器去监听ServletContext对象的创建，当ServletContext对象创建时，创建并初始化WebApplicationContext对象。因此，我们只需要在web.xml配置监听器即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 利用Spring提供的ContextLoaderListener监听器去监听ServletContext对象的创建，并初始化WebApplicationContext对象 --&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Context Configuration locations <span class="keyword">for</span> Spring XML <span class="title function_">files</span><span class="params">(默认查找/WEB-INF/applicationContext.xml)</span> --&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br></pre></td></tr></table></figure><h3 id="4、BeanFactory、ApplicationContext和WebApplicationContext的联系与区别"><a href="#4、BeanFactory、ApplicationContext和WebApplicationContext的联系与区别" class="headerlink" title="4、BeanFactory、ApplicationContext和WebApplicationContext的联系与区别"></a>4、BeanFactory、ApplicationContext和WebApplicationContext的联系与区别</h3><p>Spring通过一个配置文件描述Bean与Bean之间的依赖关系，通过Java语言的反射技术能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了bean实例缓存、生命周期管理、事件发布，资源装载等高级服务。</p><p>BeanFactory是Spring最核心的接口，提供了高级IoC的配置机制。ApplicationContext建立在BeanFactory的基础上，是BeanFactory的子接口，提供了更多面向应用的功能。我们一般称BeanFactory为<code>IoC容器</code><br>，ApplicationContext为<code>应用上下文</code>，也称为<code>Spring容器</code>。WebApplicationContext是专门为<code>Web应用准备</code><br>的，它允许以相对于Web根目录的路径中加载配置文件完成初始化工作，是ApplicationContext接口的子接口。</p><p>BeanFactory是Spring框架的基础，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用我们都直接使用ApplicationContext而非底层的BeanFactory；WebApplicationContext是专门用于Web应用。</p><h3 id="5、父子容器"><a href="#5、父子容器" class="headerlink" title="5、父子容器"></a>5、父子容器</h3><p>通过HierarchicalBeanFactory接口，Spring的IoC容器可以建立父子层级关联的体系：<code>子容器可以访问父容器的Bean，父容器不能访问子容器的Bean。</code></p><p>Spring使用父子容器实现了很多功能，比如在Spring MVC中，控制器Bean位于子容器中，业务层和持久层Bean位于父容器中。但即使这样，控制器Bean也可以引用持久层和业务层的Bean，而业务层和持久层就看不到控制器Bean。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring核心技术详解-一&quot;&gt;&lt;a href=&quot;#Spring核心技术详解-一&quot; class=&quot;headerlink&quot; title=&quot;Spring核心技术详解(一)&quot;&gt;&lt;/a&gt;Spring核心技术详解(一)&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www</summary>
      
    
    
    
    <category term="spring" scheme="http://example.com/categories/spring/"/>
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
    <category term="IOC和DI" scheme="http://example.com/tags/IOC%E5%92%8CDI/"/>
    
    <category term="表单验证" scheme="http://example.com/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://example.com/2023/04/16/git/"/>
    <id>http://example.com/2023/04/16/git/</id>
    <published>2023-04-16T04:39:10.000Z</published>
    <updated>2023-04-17T08:26:19.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><blockquote><p>之前学的，没整理</p></blockquote><h2 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h2><p>Git 是一个开源的分布式版本控制系统。</p><p>什么是版本控制？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="什么是分布式版本控制系统？"><a href="#什么是分布式版本控制系统？" class="headerlink" title="什么是分布式版本控制系统？"></a>什么是分布式版本控制系统？</h3><p>介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。</p><p>集中化的版本控制系统，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><p>这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录。</p><p><img src="https://static001.geekbang.org/infoq/ba/bad1467f92a056810239cad9a2501c45.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="img"></p><p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p><p><img src="https://static001.geekbang.org/infoq/f6/f65d9fcd054ca0198631ff88c7507571.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="img"></p><h2 id="Git-vs-SVN"><a href="#Git-vs-SVN" class="headerlink" title="Git vs SVN"></a>Git vs SVN</h2><p>Git 和 SVN 孰优孰好，每个人有不同的体验。</p><p>Git 是分布式的，SVN 是集中式的</p><p>这是 Git 和 SVN 最大的区别。若能掌握这个概念，两者区别基本搞懂大半。因为 Git 是分布式的，所以 Git 支持离线工作，在本地可以进行很多操作，包括接下来将要重磅推出的分支功能。而 SVN 必须联网才能正常工作。</p><ul><li>Git 复杂概念多，SVN 简单易上手</li></ul><p>所有同时掌握 Git 和 SVN 的开发者都必须承认，Git 的命令实在太多了，日常工作需要掌握 add,commit,status,fetch,push,rebase 等，若要熟练掌握，还必须掌握 rebase 和 merge<br>的区别，fetch 和 pull 的区别等，除此之外，还有 cherry-pick，submodule，stash 等功能，仅是这些名词听着都很绕。</p><p>在易用性这方面，SVN 对于新手来说会更有好一些。但是从另外一方面看，Git 命令多意味着功能多，若我们能掌握大部分 Git 的功能，体会到其中的奥妙，会发现再也回不去 SVN 的时代了。</p><ul><li>Git 分支廉价，SVN 分支昂贵</li></ul><p>在版本管理里，分支是很常使用的功能。在发布版本前，需要发布分支，进行大需求开发，需要 feature 分支，大团队还会有开发分支，稳定分支等。在大团队开发过程中，常常存在创建分支，切换分支的求。</p><p>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录。这个特性使 Git 的分支切换非常迅速，并且创建成本非常低。</p><p>而且 Git 有本地分支，SVN 无本地分支。在实际开发过程中，经常会遇到有些代码没写完，但是需紧急处理其他问题，若我们使用 Git，便可以创建本地分支存储没写完的代码，待问题处理完后，再回到本地分支继续完成代码。</p><h2 id="Git-基本概念"><a href="#Git-基本概念" class="headerlink" title="Git 基本概念"></a>Git 基本概念</h2><ul><li>版本库</li></ul><p>当你一个项目到本地或创建一个 git 项目，项目目录下会有一个隐藏的 .git 子目录。这个目录是 git 用来跟踪管理版本库的，千万不要手动修改。</p><ul><li>哈希值</li></ul><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git<br>就能发现。</p><p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。SHA-1 哈希看起来是这样：</p><p>24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><ul><li>文件状态</li></ul><p>在 GIt 中，你的文件可能会处于三种状态之一：</p><ul><li><p><strong>已修改（modified）</strong> - 已修改表示修改了文件，但还没保存到数据库中。</p></li><li><p><strong>已暂存（staged）</strong> - 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p></li><li><p><strong>已提交（committed）</strong> - 已提交表示数据已经安全的保存在本地数据库中。</p></li><li><p>工作区域</p></li></ul><p>与文件状态对应的，不同状态的文件在 Git 中处于不同的工作区域。</p><ul><li><strong>工作区（working</strong>） - 当你 git clone 一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li><li><strong>暂存区（staging）</strong>- 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作 &#96;‘索引’’，不过一般说法还是叫暂存区。</li><li><strong>本地仓库（local）</strong> - 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库。</li><li><strong>远程仓库（remote）</strong> - 以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新。</li></ul><p><img src="https://static001.geekbang.org/infoq/cd/cdefe604f19c6f3b4e8b484a5d7eb4ea.jpeg?x-oss-process=image/resize,p_80/auto-orient,1" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前学的，没整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Git-简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>shiro</title>
    <link href="http://example.com/2023/04/16/shrio/"/>
    <id>http://example.com/2023/04/16/shrio/</id>
    <published>2023-04-16T04:39:10.000Z</published>
    <updated>2023-04-17T08:26:45.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h2><h3 id="什么是Shiro"><a href="#什么是Shiro" class="headerlink" title="什么是Shiro?"></a>什么是Shiro?</h3><ul><li>Apache Shiro是一个Java 的<code>安全(权限)框架</code>。</li><li>Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。</li><li>Shiro可以完成，<code>认证</code>，<code>授权</code>，<code>加密</code>，<code>会话管理</code>，<code>Web集成</code>，<code>缓存</code>等.</li><li><h2 id="官网-shiro-apache-org-x2F"><a href="#官网-shiro-apache-org-x2F" class="headerlink" title="官网: shiro.apache.org&#x2F;"></a>官网: <a href="https://link.juejin.cn/?target=http://shiro.apache.org/">shiro.apache.org&#x2F;</a></h2></li></ul><p>官方文档十分钟快速入门：<a href="https://link.juejin.cn/?target=http://shiro.apache.org/10-minute-tutorial.html">shiro.apache.org&#x2F;10-minute-t…</a></p><ul><li>下载地址:<a href="https://link.juejin.cn/?target=https://github.com/apache/shiro.git">github.com&#x2F;apache&#x2F;shir…</a></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c3258b9e39b47be9614b0b113055af0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><h3 id="Shiro的三大功能"><a href="#Shiro的三大功能" class="headerlink" title="Shiro的三大功能"></a>Shiro的三大功能</h3><p>Shiro有三大核心组件，即<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realm</code></p><ul><li>Subject: 为<code>认证主体</code>。应用代码直接交互的对象是Subject,Subject代表了当前的用户。包含<code>Principals</code>和<code>Credentials</code>两个信息。</li><li>SecurityManager:为<code>安全管理员</code>。是Shiro架构的核心。与Subject的所有交互都会委托给SecurityManager,<br>Subject相当于是一个门面，而SecurityManager才是真正的执行者。它负责与Shiro 的其他组件进行交互。</li><li>Realm：是<code>一个域</code><br>。充当了Shiro与应用安全数据间的“桥梁”。Shiro从Realm中获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm中获取相应的用户进行比较，来确定用户的身份是否合法；也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能过进行，可以把Realm看成DataSource，即安全数据源。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1df3b80052a40ecb8482475e35e127f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li><code>Authentication</code>: 身份认证、登录，验证用户是不是拥有相应的身份;</li><li><code>Authorization</code>:授权,即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作，如:验证某个用户是否拥有某个角色，或者细粒度的验证某个用户对某个资源是否具有某个权限!</li><li><code>Session Manager</code>: 会话管理，即用户登录后就是第-次会话，在没有退出之前，它的所有信息都在会话中;会话可以是普通的JavaSE环境，也可以是Web环境;</li><li><code>Cryptography</code>: 加密,保护数据的安全性，如密码加密存储到数据库中，而不是明文存储;</li><li><code>Web Support</code>: Web支持，可以非常容易的集成到Web环境;</li><li><code>Caching</code>: 缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查,这样可以提高效率</li><li><code>Concurrency</code>: Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程,能把权限自动的传播过去</li><li><code>Testing</code>:提供测试支持;</li><li><code>RunAs</code>:允许一个用户假装为另-一个用户(如果他们允许)的身份进行访问;</li><li><code>Remember Me</code>:记住我，这个是非常常见的功能，即一-次登录后， 下次再来的话不用登录了</li></ul><h3 id="shiro架构（外部）"><a href="#shiro架构（外部）" class="headerlink" title="shiro架构（外部）"></a>shiro架构（外部）</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b00b0b78d68943feae4aa9832b82bb98~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><p>从外部来看Shiro,即从应用程序角度来观察如何使用shiro完成工作: Subject 用户，SecurityManager管理所有用户 Realm连接数据</p><ul><li><code>subject</code>: 应用代码直接交互的对象是Subject, 也就是说<code>Shiro</code>的对外API核心就是<code>Subject</code>,<br>Subject代表了当前的用户，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject,如网络爬虫，机器人等，与Subject的所有交互都会委托给SecurityManager; Subject其实是一一个门面，<br>SecurityManageer 才是实际的执行者。</li><li><code>SecurityManager</code>: 安全管理器，即所有与安全有关的操作都会与<code>SercurityManager</code>交互,<br>并且它管理着所有的Subject,可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC的DispatcherServlet的角色</li><li><code>Realm</code>: Shiro从Realm获取安全数据 (如用户,角色，权限)，就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较，来确定用户的身份是否合法;也需要从<code>Realm</code><br>得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把Realm看DataSource;</li></ul><h3 id="Shiro架构-内部"><a href="#Shiro架构-内部" class="headerlink" title="Shiro架构(内部)"></a>Shiro架构(内部)</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8991ce3120e94c9baccc4aae76666875~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li><code>Subject</code>: 任何可以与应用交互的用户;</li><li><code>Security Manager</code>:相当于SpringMVC中的<code>DispatcherSerlet</code>; 是Shiro的<code>心脏</code>， 所有具体的交互都通过<code>Security Manager</code>进行控制，它管理者所有的Subject,<br>且负责进行认证,授权，会话，及缓存的管理。</li><li><code>Authenticator</code>:负责<code>Subject</code>认证， 是-一个扩展点，可以自定义实现;可以使用<code>认证策略</code>(Authentication Strategy)，即什么情况下算用户认证通过了;</li><li><code>Authorizer</code>:授权器，即访问控制器，用来决定主体是否有权限进行相应的操作;即控制着用户能访问应用中 的那些功能;</li><li><code>Realm</code>: 可以有-一个或者多个的realm, 可以认为是安全实体数据源，即用于获取安全实体的，可以用JDBC实现，也可以是内存实现等等，由用户提供;所以- -般在应用中都需要实现自己的realm</li><li><code>SessionManager</code>:管理Session生 命周期的组件,而Shiro并不仅仅可以用在Web环境，也可以用在普通的JavaSE环境中</li><li><code>CacheManager</code>: 缓存控制器，来管理如用户，角色，权限等缓存的;因为这些数据基本上很少改变,放到缓存中后可以提高访问的性能;</li><li><code>Cryptography</code>:密码模块，Shiro 提高了一些常见的加密组件用于密码加密， 解密等</li></ul><h2 id="Shiro快速入门"><a href="#Shiro快速入门" class="headerlink" title="Shiro快速入门"></a>Shiro快速入门</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>下载：GitHub资源</p><p>创建一个普通maven项目springboot-08-shiro，然后删除src目录和没用的文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- configure logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-nop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更改增加版本号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>复制 <a href="https://link.juejin.cn/?target=https://github.com/apache/shiro/tree/master/samples/quickstart/src/main/resources">github.com&#x2F;apache&#x2F;shir…</a></p><p>recourse下面的log4j.properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=INFO, stdout</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n</span><br><span class="line"></span><br><span class="line"># General Apache libraries</span><br><span class="line">log4j.logger.org.apache=WARN</span><br><span class="line"></span><br><span class="line"># Spring</span><br><span class="line">log4j.logger.org.springframework=WARN</span><br><span class="line"></span><br><span class="line"># Default Shiro logging</span><br><span class="line">log4j.logger.org.apache.shiro=INFO</span><br><span class="line"></span><br><span class="line"># Disable verbose logging</span><br><span class="line">log4j.logger.org.apache.shiro.util.ThreadContext=WARN</span><br><span class="line">log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN</span><br></pre></td></tr></table></figure><p>以及shrio.ini</p><p>下载插件，下载完成之后，重启IDEA plugins –&gt; Action Tracker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line"># user <span class="string">&#x27;root&#x27;</span> with password <span class="string">&#x27;secret&#x27;</span> and the <span class="string">&#x27;admin&#x27;</span> <span class="type">role</span></span><br><span class="line"><span class="variable">root</span> <span class="operator">=</span> secret, admin</span><br><span class="line"># user <span class="string">&#x27;guest&#x27;</span> with the password <span class="string">&#x27;guest&#x27;</span> and the <span class="string">&#x27;guest&#x27;</span> <span class="type">role</span></span><br><span class="line"><span class="variable">guest</span> <span class="operator">=</span> guest, guest</span><br><span class="line"># user <span class="string">&#x27;presidentskroob&#x27;</span> with password <span class="string">&#x27;12345&#x27;</span> (<span class="string">&quot;That&#x27;s the same combination on</span></span><br><span class="line"><span class="string"># my luggage!!!&quot;</span> ;)), and role <span class="string">&#x27;president&#x27;</span></span><br><span class="line">presidentskroob = <span class="number">12345</span>, president</span><br><span class="line"># user <span class="string">&#x27;darkhelmet&#x27;</span> with password <span class="string">&#x27;ludicrousspeed&#x27;</span> and roles <span class="string">&#x27;darklord&#x27;</span> and <span class="string">&#x27;schwartz&#x27;</span></span><br><span class="line">darkhelmet = ludicrousspeed, darklord, schwartz</span><br><span class="line"># user <span class="string">&#x27;lonestarr&#x27;</span> with password <span class="string">&#x27;vespa&#x27;</span> and roles <span class="string">&#x27;goodguy&#x27;</span> and <span class="string">&#x27;schwartz&#x27;</span></span><br><span class="line">lonestarr = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"># Roles with assigned permissions</span><br><span class="line"># </span><br><span class="line"># Each line conforms to the format defined in the</span><br><span class="line"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line">[roles]</span><br><span class="line"># <span class="string">&#x27;admin&#x27;</span> role has all permissions, indicated by the wildcard <span class="string">&#x27;*&#x27;</span></span><br><span class="line">admin = *</span><br><span class="line"># The <span class="string">&#x27;schwartz&#x27;</span> role can <span class="keyword">do</span> <span class="title function_">anything</span> <span class="params">(*)</span> with any lightsaber:</span><br><span class="line">schwartz = lightsaber:*</span><br><span class="line"># The <span class="string">&#x27;goodguy&#x27;</span> role is allowed to <span class="string">&#x27;drive&#x27;</span> (action) the <span class="title function_">winnebago</span> <span class="params">(type)</span> with</span><br><span class="line"># license plate <span class="string">&#x27;eagle5&#x27;</span> (instance specific id)</span><br><span class="line">goodguy = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure><p>继续复制quickstart</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.text.IniRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.session.Session;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quickstart</span> &#123;</span><br><span class="line">    <span class="comment">//使用日志输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Quickstart.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line">        <span class="type">IniRealm</span> <span class="variable">iniRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IniRealm</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        securityManager.setRealm(iniRealm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that a simple Shiro environment is set up, let&#x27;s see what you can do:</span></span><br><span class="line">        <span class="comment">//现在设置了一个简单的Shiro环境，让我们看看您可以做什么：</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the currently executing user:</span></span><br><span class="line">        <span class="comment">//获取当前正在执行的用户：getSubject</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过当前用户拿到Session</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> currentUser.getSession();</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;someKey&quot;</span>, <span class="string">&quot;aValue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;someKey&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">&quot;aValue&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Securit=&gt;Session! [&quot;</span> + value + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这段if 就是判断当前的用户是否被认证</span></span><br><span class="line">        <span class="keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">            <span class="comment">//如果认证成功，就拿到账号密码生成一个Token令牌，没有获取，随机生成</span></span><br><span class="line">            <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;lonestarr&quot;</span>, <span class="string">&quot;vespa&quot;</span>);</span><br><span class="line">            <span class="comment">//设置记住我</span></span><br><span class="line">            token.setRememberMe(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行了登录操作！</span></span><br><span class="line">                currentUser.login(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownAccountException uae) &#123; <span class="comment">//未知的账户</span></span><br><span class="line">                log.info(<span class="string">&quot;There is no user with username of &quot;</span> + token.getPrincipal());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;<span class="comment">//密码不正常，然后输出</span></span><br><span class="line">                log.info(<span class="string">&quot;Password for account &quot;</span> + token.getPrincipal() + <span class="string">&quot; was incorrect!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LockedAccountException lae) &#123;<span class="comment">//用户被锁定，比如说输入5次失败，锁定账户</span></span><br><span class="line">                log.info(<span class="string">&quot;The account for username &quot;</span> + token.getPrincipal() + <span class="string">&quot; is locked.  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Please contact your administrator to unlock it.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span></span><br><span class="line">            <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">                <span class="comment">//unexpected condition?  error?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前用户的验证码</span></span><br><span class="line">        log.info(<span class="string">&quot;User [&quot;</span> + currentUser.getPrincipal() + <span class="string">&quot;] logged in successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试角色，比如之前的vip1，vip2</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.hasRole(<span class="string">&quot;schwartz&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;May the Schwartz be with you!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Hello, mere mortal.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否有什么权限，粗粒度！</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">&quot;lightsaber:wield&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;You may use a lightsaber ring.  Use it wisely.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果全选不满足就输出</span></span><br><span class="line">            log.info(<span class="string">&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否拥有更高级权限，细粒度！</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">&quot;winnebago:drive:eagle5&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Here are the keys - have fun!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注销</span></span><br><span class="line">        currentUser.logout();</span><br><span class="line">        <span class="comment">//结束系统</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动测试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;shiro&quot;&gt;&lt;a href=&quot;#shiro&quot; class=&quot;headerlink&quot; title=&quot;shiro&quot;&gt;&lt;/a&gt;shiro&lt;/h2&gt;&lt;h3 id=&quot;什么是Shiro&quot;&gt;&lt;a href=&quot;#什么是Shiro&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="spring" scheme="http://example.com/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>其他</title>
    <link href="http://example.com/2023/04/16/%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2023/04/16/%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-04-16T04:39:10.000Z</published>
    <updated>2023-04-17T08:24:06.931Z</updated>
    
    <content type="html"><![CDATA[<p>回顾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 三层架构</span><br><span class="line">    架构--》解耦</span><br><span class="line">  开发框架</span><br><span class="line">    spring</span><br><span class="line">      IOC AOP</span><br><span class="line">          IOC: 控制反转</span><br><span class="line">              约泡：</span><br><span class="line">                 泡温泉，泡茶，，，泡友</span><br><span class="line">                 流程：附近的人，打招呼，加微信，聊听啊----》约泡</span><br><span class="line">              浴场（容器）：温泉，茶庄，泡友</span><br><span class="line">                 直接进温泉，就有人和你一起</span><br><span class="line">              原来我们都是一步步操作，现在交给容器了，我们要就去拿</span><br><span class="line">          AOP： 切面（动态代理）</span><br><span class="line">              为了解决什么？在不影响业务本来的情况，实现动态增加，大量应用日志</span><br><span class="line">      spring是一个轻量级的java开源框架，容器</span><br><span class="line">      目的：解决企业开发的复杂性问题</span><br><span class="line">      spring是春天，也十分复杂</span><br><span class="line">    spring boot</span><br><span class="line">      新一代javaEE的开发标准，开箱机用！</span><br><span class="line">      帮我们配置非常多的东西</span><br><span class="line">      特定：约定&gt;配置</span><br><span class="line">随着公司体系越来越大，用户越来越多；</span><br><span class="line">微服务架构 --- &gt;新架构</span><br><span class="line">       模块化，功能化！</span><br><span class="line">       用户，支付，签到，娱乐,,</span><br><span class="line">       人多余多；<span class="number">1</span>台服务器不够；增加服务器！横向</span><br><span class="line">       假设A服务器 占用<span class="number">98</span>%资源，B服务器只占用<span class="number">10</span>%。-- 负载均衡</span><br><span class="line">           将整体项目分成模块化，分成模块化，用户就是一个单独的项目，项目和项目之前需要通信。如何通信？</span><br><span class="line">       用户非常多，而签到十分少  给用户多一点服务器，给签到少一点服务器！  </span><br><span class="line">微服务架构问题：</span><br><span class="line">      分布式架构会遇到的四个核心问题</span><br><span class="line">           <span class="number">1.</span> 这么多服务，客户端该如何去访问？ </span><br><span class="line">           <span class="number">2.</span> 这么多服务，服务之前如何进行通信？</span><br><span class="line">           <span class="number">3.</span> 这么多服务器，该如何治理？</span><br><span class="line">           <span class="number">4.</span> 服务挂了，怎么办？</span><br><span class="line">解决方案：</span><br><span class="line">      springcloud，是一套生态，就是来解决以上分布式架构的<span class="number">4</span>个问题。</span><br><span class="line">      想使用spring cloud，必须掌握spring boot。</span><br><span class="line">      <span class="number">1.</span> spring cloud Netflix 出来了一套解决方案</span><br><span class="line">           api网关，zuul组件</span><br><span class="line">           Feign --&gt; httpclient ---&gt;http的通信服务，同步并阻塞</span><br><span class="line">           服务注册与发现，Eureka</span><br><span class="line">           熔断机制 hystrix</span><br><span class="line">           </span><br><span class="line">           <span class="number">2018</span>年，Netflix宣布无限期停止维护，生态不再维护，就会脱节</span><br><span class="line">           </span><br><span class="line">       <span class="number">2.</span> Apache Dubbo zookeeper</span><br><span class="line">           API:没有！要么找第三方组件</span><br><span class="line">           Dubbo十一个高性能的基于java的 RPC框架</span><br><span class="line">           服务注册与发现，zookeeper</span><br><span class="line">           没有：借助了Hystrix</span><br><span class="line">            </span><br><span class="line">           不完善</span><br><span class="line">       <span class="number">3.</span> Spring Cloud Alibaba 一站式解决方案</span><br><span class="line">            </span><br><span class="line">               </span><br><span class="line">       <span class="number">4.</span> 目前又提出一种方案：</span><br><span class="line">          服务网格：下一代微服务标准</span><br><span class="line">               </span><br><span class="line">               </span><br><span class="line">万变不离其宗！</span><br><span class="line">       <span class="number">1.</span> API网关</span><br><span class="line">       <span class="number">2.</span> HTTP，RPC框架，异步调用</span><br><span class="line">       <span class="number">3.</span> 服务注册与发现，高可用</span><br><span class="line">       <span class="number">4.</span> 熔断机制，服务降级</span><br><span class="line">如果，你们基于这四个问题，开发解决方案，也叫spring cloud</span><br><span class="line">为什么解决这个问题，因为网络不可用</span><br><span class="line">           </span><br><span class="line">           </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回顾&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务阶段以及需要考虑的问题</title>
    <link href="http://example.com/2023/04/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2023/04/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-04-16T04:39:10.000Z</published>
    <updated>2023-04-17T08:26:08.245Z</updated>
    
    <content type="html"><![CDATA[<p>微服务阶段</p><p>javase:oop;</p><p>mysql:持久化；</p><p>html+css+js+jquery+框架；</p><p>javaweb:独立开发mvc三层架构；</p><p>ssm :框架</p><p>war：tomcat运行</p><p>spring再简化：springBoot -jar :内嵌tomcat;微服务;</p><p>服务越来越多 spring cloud;</p><p>阶段六： spring boot—spring cloud</p><p><img src="C:\Users\小木木\AppData\Roaming\Typora\typora-user-images\image-20230313170705578.png" alt="image-20230313170705578"></p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>用户下单 controller！</p><p>仓库解冻；资金冻结；验证；购买成功，仓库数量减少。资金解冻，仓库解冻；10s</p><p>MVC三层架构 mvvc 微服务架构</p><p>业务： service：</p><p>微服务架构区别于传统的单体软件架构，是一种为了适应当前互联网后台服务的「<strong>三高需求：高并发、高性能、高可用</strong>」而产生的的软件架构。</p><p>由于工作需要，本人曾调研过微服务相关内容，其实微服务也没什么神秘的，今天就用图解的形式了来和大家唠唠<strong>什么是微服务？</strong></p><h2 id="单体式应用程序"><a href="#单体式应用程序" class="headerlink" title="单体式应用程序"></a><strong>单体式应用程序</strong></h2><p>与微服务相对的另一个概念是传统的<strong>单体式应用程序</strong>( Monolithic application )，单体式应用内部包含了所有需要的服务。而且各个服务功能模块有很强的耦合性，也就是相互依赖彼此，很难拆分和扩容。</p><p>说在做的各位都写过单体程序，大家都没意见吧？给大家举个栗子，刚开始写代码你写的helloworld程序就是单体程序，一个程序包含所有功能，虽然 helloworld 功能很简单。</p><h3 id="单体应用程序的优点"><a href="#单体应用程序的优点" class="headerlink" title="单体应用程序的优点"></a>单体应用程序的优点</h3><ul><li>开发简洁，功能都在单个程序内部，便于软件设计和开发规划。</li><li>容易部署，程序单一不存在分布式集群的复杂部署环境，降低了部署难度。</li><li>容易测试，没有各种复杂的服务调用关系，都是内部调用方便测试。</li></ul><h3 id="单体应用程序的缺点"><a href="#单体应用程序的缺点" class="headerlink" title="单体应用程序的缺点"></a><strong>单体应用程序的缺点</strong></h3><p>单体程序的缺点一开始不是特别明显，项目刚开始需求少，业务逻辑简单，写代码一时爽，一直爽。噩梦从业务迭代更新，系统日益庞大开始，前期的爽没有了，取而代之的是软件维护和迭代更新的无尽痛苦。</p><p><img src="https://pic1.zhimg.com/80/v2-28abdbf63886720b624e7d72f9bdb418_720w.webp" alt="img"></p><p>由于单体式应用程序就像一个大型容器一样，里面放置了许多服务，且他们都是密不可分的，这导致应用程序在扩展时必须以「应用程序」为单位。</p><p>当里面有个业务模块负载过高时，并不能够单独扩展该服务，必须扩展整个应用程序（就是这么霸道），这可能导致额外的资源浪费。</p><p>此外，单体式应用程序由于服务之间的紧密度、相依性过高，这将导致测试、升级有所困难，且开发曲线有可能会在后期大幅度地上升，令开发不易。相较之下「微服务架构」能够解决这个问题。</p><h2 id="微服务-1"><a href="#微服务-1" class="headerlink" title="微服务"></a><strong>微服务</strong></h2><p>微服务 (Microservices) 就是一些协同工作小而自治的服务。</p><blockquote><p>2014年，<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a> 与 <a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/w/index.php?title=James_Lewis&action=edit&redlink=1">James Lewis</a> 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 <a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/Docker">Docker</a>) 能力，服务可以用不同的编程语言与数据库等组件实现 。「维基百科」</p></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-e4a1491d321a9389cd1e6585d354f3b7_720w.webp" alt="img"></p><p>还是拿前面的 helloworld 程序来举栗子，想象一下你是 helloworld 公司的 CTO（老板还缺人吗？会写代码的那种），假设你们公司的 helloworld 业务遍布全球，需要编写不同语种的 helloworld<br>版本，分别输出英语、日语、法语、俄语…现在世界有6000多种语言（奇怪的知识又增加了）。</p><p>有人会说这还不简单我用switch case语句就完事了，同学，不要较真我就是举个例子，现实中的业务比 helloworld 复杂多了。好了，我们姑且认为按语言输出是个庞大复杂的工作，这时候就可以用微服务架构了，架构图如下：</p><p><img src="https://pic4.zhimg.com/80/v2-10ffb1a815476a629c526ae66a510c3b_720w.webp" alt="img"></p><h2 id="微服务与SOA"><a href="#微服务与SOA" class="headerlink" title="微服务与SOA"></a><strong>微服务与SOA</strong></h2><p><strong>面向服务的体系结构</strong> SOA (Service-Oriented Architecture) 听起来和微服务很像，但 SOA<br>早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间，最终 SOA 看起来很美，但却成为了企业级奢侈品，中小公司都望而生畏。</p><p>此外，实施SOA时会遇到很多问题，比如通信协议（例如SOAP)<br>的选择、第三方中间件如何选择、服务粒度如何确定等，目前也存在一些关于如何划分系统的指导性原则，但其中有很多都是错误的。SOA并没有告诉你如何划分单体应用成微服务，所以在实施SOA时会遇到很多问题。</p><p>这些问题再微服务框架中得到很好的解决，你可以认为微服务架构是SOA的一种特定方法。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a><strong>微服务架构</strong></h2><p>合久必分，鉴于「单体应用程序」有上述的缺点，单个应用程序被划分成各种小的、互相连接的微服务，一个微服务完成一个比较单一的功能，相互之间保持独立和解耦合，这就是微服务架构。</p><h3 id="微服务优点"><a href="#微服务优点" class="headerlink" title="微服务优点"></a><strong>微服务优点</strong></h3><p>相对于单体服务，微服务有很多优点，这里列举几个主要的好处</p><h3 id="技术异构性"><a href="#技术异构性" class="headerlink" title="技术异构性"></a>技术异构性</h3><p>不同服务内部的开发技术可以不一致，你可以用java来开发helloworld服务A，用golang来开发helloworld服务B，大家再也不用为哪种语言是世界上最好的语言而争论不休。</p><p><img src="https://pic2.zhimg.com/80/v2-7562b0be8f63c7823e09d7a295d9cf99_720w.webp" alt="img"></p><p>为不同的服务选择最适合该服务的技术，系统中不同部分也可以使用不同的存储技术，比如A服务可以选择redis存储，B服务你可以选择用MySQL存储，这都是允许的，你的服务你做主。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>一个服务不可用不会导致另一个服务也瘫痪，因为各个服务是相互独立和自治的系统。这在单体应用程序中是做不到的，单体应用程序中某个模块瘫痪，必将导致整个系统不可用，当然，单体程序也可以在不同机器上部署同样的程序来实现备份，不过，同样存在上面说的资源浪费问题。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>庞大的单体服务如果出现性能瓶颈只能对软件整体进行扩展，可能真正影响性能的只是其中一个很小的模块，我们也不得不付出升级整个应用的代价。这在微服务架构中得到了改善，你可以只对那些影响性能的服务做扩展升级，这样对症下药的效果是很好的。</p><h3 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h3><p>如果你的服务是一个超大的单体服务，有几百万行代码，即使修改了几行代码也要重新编译整个应用，这显然是非常繁琐的，而且软件变更带来的不确定性非常高，软件部署的影响也非常大。在微服务架构中，各个服务的部署是独立的，如果真出了问题也只是影响单个服务，可以快速回滚版本解决。</p><h3 id="易优化"><a href="#易优化" class="headerlink" title="易优化"></a>易优化</h3><p>微服务架构中单个服务的代码量不会很大，这样当你需要重构或者优化这部分服务的时候，就会容易很多，毕竟，代码量越少意味着代码改动带来的影响越可控。</p><h3 id="微服务缺点"><a href="#微服务缺点" class="headerlink" title="微服务缺点"></a><strong>微服务缺点</strong></h3><p>我们上面一直在强调微服务的好处，但是，微服务架构不是万能的，并不能解决所有问题，其实这也是微服务把单体应用拆分成很多小的分布式服务导致的，所谓人多手杂，服务多起来管理的不好各种问题就来了。</p><p>为了解决微服务的缺点，前辈们提出了下面这些概念。</p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>微服务之间相互调用完成整体业务功能，如何在众多微服务中找到正确的目标服务地址，这就是所谓「服务发现」功能。</p><p>常用的做法是服务提供方启动的时候把自己的地址上报给「服务注册中心」，这就是「服务注册」。服务调用方「订阅」服务变更「通知」，动态的接收服务注册中心推送的服务地址列表，以后想找哪个服务直接发给他就可以。</p><p><img src="https://pic2.zhimg.com/80/v2-3578297e7768e6c99d1fa1f33ebde659_720w.webp" alt="img"></p><h3 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h3><p>单体程序的监控运维还好说，大型微服务架构的服务运维是一大挑战。服务运维人员需要实时的掌握服务运行中的各种状态，最好有个控制面板能看到服务的内存使用率、调用次数、健康状况等信息。</p><p>这就需要我们有一套完备的服务监控体系，包括拓扑关系、监控（Metrics）、日志监控（Logging）、调用追踪（Trace）、告警通知、健康检查等，防患于未然。</p><h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><p>任何服务都不能保证100%不出问题，生产环境复杂多变，服务运行过程中不可避免的发生各种故障（宕机、过载等等），工程师能够做的是在故障发生时尽可能降低影响范围、尽快恢复正常服务。</p><p>程序员为此避免被祭天，需要引入「熔断、隔离、限流和降级、超时机制」等「服务容错」机制来保证服务持续可用性。</p><h3 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h3><p>有些服务的敏感数据存在安全问题，「服务安全」就是对敏感服务采用安全鉴权机制，对服务的访问需要进行相应的身份验证和授权，防止数据泄露的风险，安全是一个长久的话题，在微服务中也有很多工作要做。</p><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a><strong>服务治理</strong></h2><p>说到「治理」一般都是有问题才需要治理，我们平常说环境治理、污染治理一个意思，微服务架构中的微服务越来越多，上面说的那些问题就更加显现，为了解决上面微服务架构缺陷「服务治理」就出现了。</p><p><img src="https://pic1.zhimg.com/80/v2-238e741a39592caeb236a001013580a0_720w.webp" alt="img"></p><p>微服务的那些问题都要公司技术团队自己解决的话，如果不是大型公司有成熟的技术团队，估计会很头大。幸好，有巨人的肩膀可以借给我们站上去，通过引入「微服务框架」来帮助我们完成服务治理。</p><h2 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a><strong>微服务框架</strong></h2><p>介绍一些业界比较成熟的微服务框架。</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a><strong>Dubbo</strong></h3><p>是阿里巴巴公司开源的一个Java高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java<br>RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现 。2011 年末对外开源，仅支持 Java 语言。</p><p>官网：<a href="https://link.zhihu.com/?target=http://dubbo.apache.org/zh-cn/">http://dubbo.apache.org/zh-cn/</a></p><h3 id="Tars"><a href="#Tars" class="headerlink" title="Tars"></a><strong>Tars</strong></h3><p>腾讯内部使用的微服务架构 TAF（Total Application Framework）多年的实践成果总结而成的开源项目。 仅支持 C++ 语言，目前在腾讯内部应用也非常广泛。2017 年对外开源，仅支持 C++ 语言。</p><p>源码： <a href="https://link.zhihu.com/?target=https://github.com/TarsCloud/Tars/">https://github.com/TarsCloud/Tars/</a></p><p><img src="https://pic3.zhimg.com/80/v2-8fe78be188c0577ec94e2fb443ec09e2_720w.webp" alt="img"></p><h2 id="工作原因，本身用的较多的是腾讯自研-TARS-框架，这个RPC框架的详细介绍-PPT-已下载，文末也给出了。"><a href="#工作原因，本身用的较多的是腾讯自研-TARS-框架，这个RPC框架的详细介绍-PPT-已下载，文末也给出了。" class="headerlink" title="工作原因，本身用的较多的是腾讯自研 TARS 框架，这个RPC框架的详细介绍 PPT 已下载，文末也给出了。"></a><strong>工作原因，本身用的较多的是腾讯自研 TARS 框架，这个RPC框架的详细介绍 PPT 已下载，文末也给出了。</strong></h2><h3 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a><strong>Motan</strong></h3><p>是新浪微博开源的一个Java 框架。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。于 2016 年对外开源，仅支持 Java 语言。</p><p>官方指南： <a href="https://link.zhihu.com/?target=https://github.com/weibocom/motan/wiki/zh_userguide">https://github.com/weibocom/motan/wiki/zh_userguide</a></p><p><img src="https://pic3.zhimg.com/80/v2-8980cffbcf69b0987418b0b003d2a1a2_720w.webp" alt="img"></p><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a><strong>gRPC</strong></h3><p>是Google开发的高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP&#x2F;2协议标准而设计，基于ProtoBuf(Protocol Buffers)<br>序列化协议开发。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。2015 年对外开源的跨语言 RPC 框架，支持多种语言。</p><p>中文教程：<a href="https://link.zhihu.com/?target=https://doc.oschina.net/grpc?t=58008">https://doc.oschina.net/grpc?t=58008</a></p><p><img src="https://pic4.zhimg.com/80/v2-c0eb4a1e7411af2da9ffa76b9969ef33_720w.webp" alt="img"></p><h3 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a><strong>thrift</strong></h3><p>最初是由 Facebook 开发的内部系统跨语言的高性能 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一， 跟 gRPC 一样，Thrift 也有一套自己的接口定义语言<br>IDL，可以通过代码生成器，生成各种编程语言的 Client 端和 Server 端的 SDK 代码，支持多种语言。</p><p><img src="https://pic2.zhimg.com/80/v2-08205252ae7a4b5632c3087ff7167a85_720w.webp" alt="img"></p><h2 id="微服务框架和RPC"><a href="#微服务框架和RPC" class="headerlink" title="微服务框架和RPC"></a><strong>微服务框架和RPC</strong></h2><p>很多人对这两个概念有点混淆，微服务框架上面我们说过了，我们再来看下RPC的概念。</p><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a><strong>什么是RPC</strong></h3><p>RPC (Remote Procedure Call)<br>远程过程调用是一个计算机通信协议。我们一般的程序调用是本地程序内部的调用，RPC允许你像调用本地函数一样去调用另一个程序的函数，这中间会涉及网络通信和进程间通信，但你无需知道实现细节，RPC框架为你屏蔽了底层实现。RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过**<br>发送请求-接受回应**进行信息交互的系统。</p><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a><strong>两者关系</strong></h3><p>RPC和微服务框架的关系我的理解，微服务框架一般都包含了RPC的实现和一系列「服务治理」能力，是一套软件开发框架。我们可以基于这个框架之上实现自己的微服务，方便的利用微服务框架提供的「服务治理」能力和RPC能力，所以微服务框架也被有些人称作RPC框架。</p><h2 id="下一代微服务架构"><a href="#下一代微服务架构" class="headerlink" title="下一代微服务架构"></a><strong>下一代微服务架构</strong></h2><p>Service Mesh（服务网格）被认为是下一代微服务架构，Service Mesh并没有给我们带来新的功能，它是用于解决其他工具已经解决过的服务网络调用、限流、熔断和监控等问题，只不过这次是在Cloud Native 的<br>kubernetes 环境下的实现。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>Service Mesh 有如下几个特点：</p><ul><li>应用程序间通讯的中间层</li><li>轻量级网络代理</li><li>应用程序无感知</li><li>解耦应用程序的重试&#x2F;超时、监控、追踪和服务发现</li></ul><p>目前两款流行的 Service Mesh 开源软件 <a href="%5Bhttps://istio.io/%5D(https://link.zhihu.com/?target=https://istio.io/)">Istio</a><br>和 <a href="%5Bhttps://linkerd.io/%5D(https://link.zhihu.com/?target=https://linkerd.io/)">Linkerd</a>都可以直接在kubernetes<br>中集成，其中Linkerd已经成为云原生计算基金会 CNCF (Cloud Native Computing Foundation) 成员。</p><h3 id="Why-Service-Mesh"><a href="#Why-Service-Mesh" class="headerlink" title="Why Service Mesh"></a><strong>Why Service Mesh</strong></h3><p>为什么现有微服务架构已经解决的问题还要用Service Mesh呢？这个问题问的好。</p><p><img src="https://pic1.zhimg.com/80/v2-a7de7ff7d10faf4f58b8bee244d50e60_720w.webp" alt="img"></p><p>回答问题之前，先看下<a href="https://link.zhihu.com/?target=http://istio.io">http://istio.io</a>上对service mesh的解释，我觉得挺好的，摘抄出来：</p><blockquote><p>As a service mesh grows in size and complexity, it can become harder to understand and manage. Its requirements can include discovery, load balancing, failure recovery, metrics, and monitoring. A service mesh also often has more complex operational requirements, like A&#x2F;B testing, canary rollouts, rate limiting, access control, and end-to-end authentication. makes it easy to create a network of deployed services with load balancing, service-to-service authentication, monitoring, and more, <strong>with few or no code changes in service code.</strong></p></blockquote><p>试着总结一下：随着微服务的增多复杂程度也增加，管理变得更加困难，微服务架构虽然解决了「网络调用、限流、熔断和监控」等问题，但大多数框架和开源软件对原有业务是侵入式的，也就是需要在业务服务程序中集成相关的「服务治理」组件。</p><p>Service Mesh之于微服务，就像TCP&#x2F;IP之于互联网，TCP&#x2F;IP为网络通信提供了面向连接的、可靠的、基于字节流的基础通信功能，你不再需要关心底层的重传、校验、流量控制、拥塞控制。</p><p>用了Service Mesh你也不必去操心「服务治理」的细节，不需要对服务做特殊的改造，所有业务之外的功能都由Service Mesh帮你去做了。它就像一个轻量级网络代理<br>对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 serivce mesh 中实现 。</p><p><img src="https://pic3.zhimg.com/80/v2-2a2e5b537c564ad8cf1dcd1b47d5d68a_720w.webp" alt="img"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a><strong>写在最后</strong></h2><p>在IT世界没有什么技术是永不过时的，微服务架构的演进就是一个例子，从单体程序到微服务架构，再到service mesh架构，我不知道下一个技术迭代点是什么时候，但我知道微服务架构肯定还会更新，IT人更应该建立终身学习习惯。<br>当然更重要的是拥有对技术的热情，热于拥抱变化、接受新技术，当我看到新技术我是兴奋的，内心os是厉害了，还能这么玩！，希望你也有这般热情，而不仅仅是面向工资编程，生活会有趣很多。</p><h3 id="你主导面试官"><a href="#你主导面试官" class="headerlink" title="你主导面试官"></a>你主导面试官</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微服务阶段&lt;/p&gt;
&lt;p&gt;javase:oop;&lt;/p&gt;
&lt;p&gt;mysql:持久化；&lt;/p&gt;
&lt;p&gt;html+css+js+jquery+框架；&lt;/p&gt;
&lt;p&gt;javaweb:独立开发mvc三层架构；&lt;/p&gt;
&lt;p&gt;ssm :框架&lt;/p&gt;
&lt;p&gt;war：tomcat运行&lt;/</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>其他</title>
    <link href="http://example.com/2023/04/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/"/>
    <id>http://example.com/2023/04/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%81/</id>
    <published>2023-04-16T04:39:10.000Z</published>
    <updated>2023-04-17T08:25:42.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解synchronized底层原理，一篇文章就够了！"><a href="#深入理解synchronized底层原理，一篇文章就够了！" class="headerlink" title="深入理解synchronized底层原理，一篇文章就够了！"></a>深入理解synchronized底层原理，一篇文章就够了！</h1><ul><li>前言</li><li>一、synchronized的特性<ul><li>1.1 原子性</li><li>1.2 可见性</li><li>1.3 有序性</li><li>1.4 可重入性</li></ul></li><li>二、synchronized的用法</li><li>三、synchronized锁的实现<ul><li>3.1 同步方法</li><li>3.2 同步代码块</li></ul></li><li>四、synchronized锁的底层实现</li><li>五、JVM对synchronized的优化<ul><li>5.1 锁膨胀<ul><li>5.1.1 偏向锁</li><li>5.1.2 轻量级锁</li><li>5.1.3 重量级锁</li></ul></li><li>5.2 锁消除</li><li>5.3 锁粗化</li><li>5.4 自旋锁与自适应自旋锁</li></ul></li><li>结语</li><li><strong>前言</strong></li></ul><p>如果某一个资源被多个线程共享，为了避免因为资源抢占导致资源数据错乱，我们需要对线程进行同步，那么synchronized就是实现线程同步的关键字，可以说在并发控制中是必不可少的部分，今天就来看一下synchronized的使用和底层原理。</p><h1 id="一、synchronized的特性"><a href="#一、synchronized的特性" class="headerlink" title="一、synchronized的特性"></a><strong>一、synchronized的特性</strong></h1><h2 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a><strong>1.1 原子性</strong></h2><p><strong>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong></p><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。但是像i++、i+&#x3D;1等操作字符就不是原子性的，它们是分成<strong>读取、计算、赋值</strong><br>几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。</p><p>被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断（除了已经废弃的stop()方法），即保证了原子性。</p><p><strong>注意！面试时经常会问比较synchronized和volatile，它们俩特性上最大的区别就在于原子性，volatile不具备原子性。</strong></p><h2 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a><strong>1.2 可见性</strong></h2><p><strong>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</strong></p><p>synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</p><p>而volatile的实现类似，被volatile修饰的变量，每当值需要修改时都会立即更新主存，主存是共享的，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性。</p><h2 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3 有序性"></a><strong>1.3 有序性</strong></h2><p><strong>有序性值程序执行的顺序按照代码先后执行。</strong></p><p>synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</p><h2 id="1-4-可重入性"><a href="#1-4-可重入性" class="headerlink" title="1.4 可重入性"></a><strong>1.4 可重入性</strong></h2><p>synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</p><h1 id="二、synchronized的用法"><a href="#二、synchronized的用法" class="headerlink" title="二、synchronized的用法"></a><strong>二、synchronized的用法</strong></h1><p>synchronized可以修饰静态方法、成员函数，同时还可以直接定义代码块，但是归根结底它上锁的资源只有两类：一个是<strong>对象</strong>，一个是<strong>类</strong>。</p><p>先看看下面的代码（初学者看到先不要晕，后面慢慢讲解）：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/7fppcq4izk.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>首先我们知道被<code>static</code><br>修饰的静态方法、静态属性都是归类所有，同时该类的所有实例对象都可以访问。但是普通成员属性、成员方法是归实例化的对象所有，必须实例化之后才能访问，这也是为什么静态方法不能访问非静态属性的原因。我们明确了这些属性、方法归哪些所有之后就可以理解上面几个synchronized的锁到底是加给谁的了。</p><p>首先看第一个synchronized所加的方法是<code>add1()</code>，该方法没有被<code>static</code>修饰，也就是说该方法是归实例化的对象所有，那么这个锁就是加给Test1类所实例化的对象。</p><p>然后是<code>add2()</code>方法，该方法是静态方法，归Test1类所有，所以这个锁是加给Test1类的。</p><p>最后是<code>method()</code>方法中两个同步代码块，第一个代码块所锁定的是<code>Test1.class</code>，通过字面意思便知道该锁是加给Test1类的，而下面那个锁定的是<code>instance</code><br>，这个instance是Test1类的一个实例化对象，自然它所上的锁是给instance实例化对象的。</p><p>弄清楚这些锁是上给谁的就应该很容易懂synchronized的使用啦，只要记住要进入同步方法或同步块必须先获得相应的锁才行。那么我下面再列举出一个非常容易进入误区的代码，看看你是否真的理解了上面的解释。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/bdx17z87nc.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>上面的简单意思就是用两个线程分别对i加100万次，理论结果应该是200万，而且我还加了synchronized锁住了add方法，保证了其线程安全性。可是！！！我无论运行多少次都是小于200万的，为什么呢？</p><p>原因就在于synchronized加锁的函数，这个方法是普通成员方法，那么锁就是加给对象的，但是<strong>在创建线程时却new了两个Test2实例，也就是说这个锁是给这两个实例加的锁，并没有达到同步的效果</strong><br>，所以才会出现错误。至于为什么小于200万，要理解<code>i++</code>的过程就明白了，我之前写了一篇文章讲解过这个过程，请阅读：<a href="https://mp.weixin.qq.com/s?__biz=MzU3OTkyMDAxNg==&mid=2247483817&idx=1&sn=1d782e56995356dec7eaeb8749260c61&chksm=fd5f8856ca280140e21ded04dd6304ae8832a160505e632800a8ce245e3a1b1fea27b3b3671a&token=268872677&lang=zh_CN&scene=21#wechat_redirect">**<br>详谈Java中的CAS操作**</a></p><h1 id="三、synchronized锁的实现"><a href="#三、synchronized锁的实现" class="headerlink" title="三、synchronized锁的实现"></a><strong>三、synchronized锁的实现</strong></h1><p>synchronized有两种形式上锁，一个是对方法上锁，一个是构造同步代码块。他们的底层实现其实都一样，在进入同步代码之前先获取锁，获取到锁之后锁的计数器+1，同步代码执行完锁的计数器-1，如果获取失败就阻塞式等待锁的释放。只是他们在同步块识别方式上有所不一样，从class字节码文件可以表现出来，一个是通过方法flags标志，一个是monitorenter和monitorexit指令操作。</p><h2 id="3-1-同步方法"><a href="#3-1-同步方法" class="headerlink" title="3.1 同步方法"></a><strong>3.1 同步方法</strong></h2><p>首先来看在方法上上锁，我们就新定义一个同步方法然后进行反编译，查看其字节码：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/wdzcv6eszv.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/mbe3ktwj6h.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>可以看到在add方法的flags里面多了一个<code>ACC_SYNCHRONIZED</code>标志，这标志用来告诉JVM这是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，知道该锁被释放。</p><p>如果看不懂字节码指令的朋友可以先阅读我之前写的两篇文章，了解一下class的结构：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3OTkyMDAxNg==&mid=2247484028&idx=1&sn=a84dc06e221444cfed73fcb60322678f&chksm=fd5f8b83ca2802950e7bc4ae28f5fe80a463c78996acee09904a2a2a8d7f19d11a92289f559e&scene=21#wechat_redirect">**<br>详解Class类文件的结构（上）**</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3OTkyMDAxNg==&mid=2247484033&idx=1&sn=9fde746119825b09faa08a36d142bec4&chksm=fd5f8b7eca2802682f03ce38f9d51fb59ec033c54cb776836161f7151939020bfe76113f3034&token=268872677&lang=zh_CN&scene=21#wechat_redirect">**<br>详解Class类文件的结构（下）**</a></li></ul><h2 id="3-2-同步代码块"><a href="#3-2-同步代码块" class="headerlink" title="3.2 同步代码块"></a><strong>3.2 同步代码块</strong></h2><p>我们新定义一个同步代码块，编译出class字节码，然后找到method方法所在的指令块，可以清楚的看到其实现上锁和释放锁的过程，截图如下：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/8v9z1ullj9.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/445esedcaq.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>从反编译的同步代码块可以看到同步块是由monitorenter指令进入，然后monitorexit释放锁，在执行monitorenter之前需要尝试获取锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，那么就把锁的计数器加1。当执行monitorexit指令时，锁的计数器也会减1。当获取锁失败时会被阻塞，一直等待锁被释放。</p><p>但是为什么会有两个monitorexit呢？其实第二个monitorexit是来处理异常的，仔细看反编译的字节码，正常情况下第一个monitorexit之后会执行<code>goto</code>指令，而该指令转向的就是23行的<code>return</code><br>，也就是说正常情况下只会执行第一个monitorexit释放锁，然后返回。而如果在执行中发生了异常，第二个monitorexit就起作用了，它是由编译器自动生成的，在发生异常时处理异常然后释放掉锁。</p><h1 id="四、synchronized锁的底层实现"><a href="#四、synchronized锁的底层实现" class="headerlink" title="四、synchronized锁的底层实现"></a><strong>四、synchronized锁的底层实现</strong></h1><p>在理解锁实现原理之前先了解一下Java的对象头和Monitor，在JVM中，对象是分成三部分存在的：对象头、实例数据、对其填充。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/fu98yi2bmj.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><p>实例数据和对其填充与synchronized无关，这里简单说一下（我也是阅读《深入理解Java虚拟机》学到的，读者可仔细阅读该书相关章节学习）。<strong>实例数据</strong><br>存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐；<strong>对其填充</strong>不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充仅仅是为了使字节对齐。</p><p>对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 和 <code>Class Metadata Address</code>组成，**<br>其中**<code>**Mark Word**</code><strong>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>，<code>**Class Metadata Address**</code>**<br>是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例**。</p><p>锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong><br>，其中无锁就是一种状态了。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p><p>每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="variable constant_">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">//锁计数器</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="variable constant_">NULL</span>;</span><br><span class="line">    _owner        = <span class="variable constant_">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="variable constant_">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="variable constant_">NULL</span> ;</span><br><span class="line">    _succ         = <span class="variable constant_">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="variable constant_">NULL</span> ;</span><br><span class="line">    <span class="title class_">FreeNext</span>      = <span class="variable constant_">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="variable constant_">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    <span class="title class_">OwnerIsThread</span> = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>复制</p><blockquote><p>该段摘自：<a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a>  ObjectMonitor中有两个队列_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入_EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。 monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify&#x2F;notifyAll&#x2F;wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)</p></blockquote><h1 id="五、JVM对synchronized的优化"><a href="#五、JVM对synchronized的优化" class="headerlink" title="五、JVM对synchronized的优化"></a><strong>五、JVM对synchronized的优化</strong></h1><p>从最近几个jdk版本中可以看出，Java的开发团队一直在对synchronized优化，其中最大的一次优化就是在jdk6的时候，新增了两个锁状态，通过锁消除、锁粗化、自旋锁等方法使用各种场景，给synchronized性能带来了很大的提升。</p><h2 id="5-1-锁膨胀"><a href="#5-1-锁膨胀" class="headerlink" title="5.1 锁膨胀"></a><strong>5.1 锁膨胀</strong></h2><p>上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，并且膨胀方向不可逆。</p><h3 id="5-1-1-偏向锁"><a href="#5-1-1-偏向锁" class="headerlink" title="5.1.1 偏向锁"></a><strong>5.1.1 偏向锁</strong></h3><p>一句话总结它的作用：<strong>减少统一线程获取锁的代价</strong>。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。</p><p><strong>核心思想：</strong></p><p>如果一个线程获得了锁，那么锁就进入偏向模式，此时<code>Mark Word</code>的结构也就变为偏向锁结构，<strong>当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查</strong><code>**Mark Word**</code>**<br>的锁标记位为偏向锁以及当前线程ID等于**<code>**Mark Word**</code><strong>的ThreadID即可</strong>，这样就省去了大量有关锁申请的操作。</p><h3 id="5-1-2-轻量级锁"><a href="#5-1-2-轻量级锁" class="headerlink" title="5.1.2 轻量级锁"></a><strong>5.1.2 轻量级锁</strong></h3><p>轻量级锁是由偏向锁升级而来，当存在第二个线程申请同一个锁对象时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。</p><h3 id="5-1-3-重量级锁"><a href="#5-1-3-重量级锁" class="headerlink" title="5.1.3 重量级锁"></a><strong>5.1.3 重量级锁</strong></h3><p>重量级锁是由轻量级锁升级而来，当<strong>同一时间</strong>有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。</p><p>重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。</p><h2 id="5-2-锁消除"><a href="#5-2-锁消除" class="headerlink" title="5.2 锁消除"></a><strong>5.2 锁消除</strong></h2><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。比如下面代码的method1和method2的执行效率是一样的，因为object锁是私有变量，不存在所得竞争关系。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/crldlzz0n7.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><h2 id="5-3-锁粗化"><a href="#5-3-锁粗化" class="headerlink" title="5.3 锁粗化"></a><strong>5.3 锁粗化</strong></h2><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。比如下面method3经过锁粗化优化之后就和method4执行效率一样了。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5522483/vra4opn4on.webp?imageView2/2/w/1620/format/jpg" alt="img"></p><h2 id="5-4-自旋锁与自适应自旋锁"><a href="#5-4-自旋锁与自适应自旋锁" class="headerlink" title="5.4 自旋锁与自适应自旋锁"></a><strong>5.4 自旋锁与自适应自旋锁</strong></h2><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。</p><p><strong>自适应自旋锁</strong>：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h1><p>synchronized关键字是并发编程不可或缺的部分，个人认为能真实理解其内部运作原理能对平时的开发带来很大意义上的帮助，希望这篇文章能帮助你！</p><p>文章分享自微信公众号：</p><p><img src="https://open.weixin.qq.com/qr/code?username=gh_f1c6f5c801ce" alt="img"></p><p>北风IT之路</p><p>复制公众号名称</p><p>本文参与 <a href="https://cloud.tencent.com/developer/support-plan">腾讯云自媒体分享计划</a> ，欢迎热爱写作的你一起参与！</p><p>作者：beifengtz</p><p>原始发表时间：2019-07-15</p><p>如有侵权，请联系 <a href="mailto:&#x63;&#x6c;&#x6f;&#117;&#x64;&#x63;&#111;&#109;&#x6d;&#117;&#110;&#105;&#116;&#121;&#64;&#x74;&#101;&#x6e;&#x63;&#101;&#x6e;&#x74;&#46;&#x63;&#111;&#109;">&#x63;&#x6c;&#x6f;&#117;&#x64;&#x63;&#111;&#109;&#x6d;&#117;&#110;&#105;&#116;&#121;&#64;&#x74;&#101;&#x6e;&#x63;&#101;&#x6e;&#x74;&#46;&#x63;&#111;&#109;</a> 删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解synchronized底层原理，一篇文章就够了！&quot;&gt;&lt;a href=&quot;#深入理解synchronized底层原理，一篇文章就够了！&quot; class=&quot;headerlink&quot; title=&quot;深入理解synchronized底层原理，一篇文章就够了！&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="spring" scheme="http://example.com/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>自动装配的原理</title>
    <link href="http://example.com/2023/04/06/spring%20boot%20web%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2023/04/06/spring%20boot%20web%E5%BC%80%E5%8F%91/</id>
    <published>2023-04-06T04:39:10.000Z</published>
    <updated>2023-04-17T08:23:41.879Z</updated>
    
    <content type="html"><![CDATA[<p>自动配置的精髓：</p><ol><li>spring boot启动会加载大量的自动配置类</li><li>我们看我们需要的功能有没有在springboot默认写好的自动配置类</li><li>只要我们要用的配置类在其中，就不需要手动配置了</li><li>给容器中自动配置类添加组件时，会从properites类中获取某些元素，我们只需要在配置文件中指定所给这些属性的值</li><li>xxxxAutoCOnfiguration : 自动配置类</li><li>xxxxProperities: 封装配置文件中的相关属性。</li></ol><h1 id="spring-boot-web开发"><a href="#spring-boot-web开发" class="headerlink" title="spring boot web开发"></a>spring boot web开发</h1><p>jar：webapp！</p><p>自动装配：</p><blockquote><p>spring boot到底帮我配置了什么？能不能修改和扩展</p><ol><li>xxxxAutoCOnfiguration : 自动配置类</li><li>xxxxProperities: 封装配置文件中的相关属性。</li></ol></blockquote><ol><li>创建应用，选择模版</li><li>面向过程</li></ol><p>要解决的问题：</p><ul><li>导入静态资源</li><li>首页</li><li>jsp，模版引擎 Thymleaf</li><li>装配扩展SpringMVC</li><li>增删改查</li><li>拦截器</li><li>国际化！</li></ul><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    addResourceHandler(registry, <span class="built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">        registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ServletContextResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext, SERVLET_LOCATION);</span><br><span class="line">            registration.addResourceLocations(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是webjars’:<br>WebJars是将web前端资源（js，css等）打成jar包文件，然后借助Maven工具，以jar包形式对web前端资源进行统一依赖管理，保证这些Web资源版本唯一性。WebJars的jar包部署在Maven中央仓库上。</p><p>拿到静态资源的第一种方式</p><blockquote><p><a href="http://localhost:8080/webjars/github-com-jquery-jquery/3.4.1/jquery.js">http://localhost:8080/webjars/github-com-jquery-jquery/3.4.1/jquery.js</a></p></blockquote><p>使用&#x2F;**&#x2F;static或者&#x2F;resources或者&#x2F;public来访问静态资源</p><blockquote><p>localhost：8080&#x2F;**&#x2F;</p></blockquote><blockquote><p>优先级：resources&gt;static（默认）&gt;puiblic</p></blockquote><p>很少使用webjars</p><p>为什么在chrome浏览器按 ctrl + F5 就能生效呢？</p><blockquote><p>当你的项目从没有favicon.ico图标文件到有favicon.ico图标后的状态下，在浏览器中按 F5 刷新后，在缓存的机制下，它并不会去请求服务器去下载这个favicon.ico文件（即便你设置了静态资源的热部署），所以这个图标自然无法显示在浏览器上；那么按 ctrl + F5 之后，会强制浏览器重新去服务器下载静态资源，所以就会把新加载到项目的favicon.ico文件下载下来，那么浏览器自然而然就能显示这个图标了！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动配置的精髓：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;spring boot启动会加载大量的自动配置类&lt;/li&gt;
&lt;li&gt;我们看我们需要的功能有没有在springboot默认写好的自动配置类&lt;/li&gt;
&lt;li&gt;只要我们要用的配置类在其中，就不需要手动配置了&lt;/li&gt;
&lt;li&gt;给容器中</summary>
      
    
    
    
    <category term="spring boot" scheme="http://example.com/categories/spring-boot/"/>
    
    
  </entry>
  
  <entry>
    <title>springSecurity</title>
    <link href="http://example.com/2023/04/06/springSecurity(%E5%AE%89%E5%85%A8)/"/>
    <id>http://example.com/2023/04/06/springSecurity(%E5%AE%89%E5%85%A8)/</id>
    <published>2023-04-06T04:39:10.000Z</published>
    <updated>2023-04-17T08:29:17.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springSecurity-安全"><a href="#springSecurity-安全" class="headerlink" title="springSecurity(安全)"></a>springSecurity(安全)</h2><p>在web开发中，安全第一位！ 过滤性，拦截器</p><p>做网站：安全应该在什么时候考虑？设计之初</p><p>在 Web<br>开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。<br>市面上存在比较有名的：Shiro，Spring Security ！ 这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？<br>首先我们看下它的官网介绍：Spring Security官网地址 Spring Security is a powerful and highly customizable authentication and access-control<br>framework. It is the de-facto standard for securing Spring-based applications. Spring Security is a framework that<br>focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real<br>power of Spring Security is found in how easily it can be extended to meet custom requirements Spring<br>Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。 Spring<br>Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求<br>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。<br>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。 Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring<br>框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。<br>用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<br>用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。<br>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。 在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和<br>LDAP 等。 在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。 2、环境搭建 3、认证和授权<br>3.1、认识SpringSecurity Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入<br>spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p><p>记住几个类：</p><p>WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式<br>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p><p>“认证”（Authentication）</p><p>身份验证是关于验证您的凭据，如用户名&#x2F;用户ID和密码，以验证您的身份。</p><p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p><p>“授权” （Authorization）</p><p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p><p>这个概念是通用的，而不是只在Spring Security 中存在。</p><p>3.2、配置 使用 Spring Security 增加上认证和授权的功能</p><p>1、引入 Spring Security 模块</p><h3 id="1-认证"><a href="#1-认证" class="headerlink" title="1.认证"></a>1.认证</h3><h3 id="2-授权"><a href="#2-授权" class="headerlink" title="2.授权"></a>2.授权</h3><p>两个方面：晚上总结</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;springSecurity-安全&quot;&gt;&lt;a href=&quot;#springSecurity-安全&quot; class=&quot;headerlink&quot; title=&quot;springSecurity(安全)&quot;&gt;&lt;/a&gt;springSecurity(安全)&lt;/h2&gt;&lt;p&gt;在web开发中，</summary>
      
    
    
    
    <category term="spring boot" scheme="http://example.com/categories/spring-boot/"/>
    
    
  </entry>
  
  <entry>
    <title>狂神说spring boot第一讲 hello world</title>
    <link href="http://example.com/2023/04/06/%E7%8B%82%E7%A5%9E%E8%AF%B4spring%20boot%E7%AC%AC%E4%B8%80%E8%AE%B2%20hello%20world/"/>
    <id>http://example.com/2023/04/06/%E7%8B%82%E7%A5%9E%E8%AF%B4spring%20boot%E7%AC%AC%E4%B8%80%E8%AE%B2%20hello%20world/</id>
    <published>2023-04-06T04:39:10.000Z</published>
    <updated>2023-04-17T08:25:02.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="狂神说spring-boot第一讲-hello-world"><a href="#狂神说spring-boot第一讲-hello-world" class="headerlink" title="狂神说spring boot第一讲 hello world"></a>狂神说spring boot第一讲 hello world</h1><h2 id="回顾什么是Spring"><a href="#回顾什么是Spring" class="headerlink" title="回顾什么是Spring"></a>回顾什么是Spring</h2><p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。</p><p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p><h2 id="Spring是如何简化Java开发的"><a href="#Spring是如何简化Java开发的" class="headerlink" title="Spring是如何简化Java开发的"></a>Spring是如何简化Java开发的</h2><p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p><p>1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；</p><p>2、通过IOC，依赖注入（DI）和面向接口实现松耦合；</p><p>3、基于切面（AOP）和惯例进行声明式编程；</p><p>4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</p><h2 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h2><p>学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello<br>Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍；</p><p>言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”<br>，能迅速的开发web应用，几行代码开发一个http接口。</p><p>所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生<br>一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p><p>是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p><p>随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot<br>正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring<br>的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring<br>配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p><p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p><p>Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。</p><p><strong>Spring Boot的主要优点：</strong></p><ul><li>为所有Spring开发者更快的入门</li><li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求</li></ul><p>真的很爽，我们快速去体验开发个接口的感觉吧！</p><p><strong>项目结构分析：</strong></p><p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p><p>1、程序的主启动类</p><p>2、一个 application.properties 配置文件</p><p>3、一个 测试类</p><p>4、一个 pom.xml</p><h2 id="pom-xml-分析"><a href="#pom-xml-分析" class="headerlink" title="pom.xml 分析"></a>pom.xml 分析</h2><p>打开pom.xml，看看Spring Boot项目的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web场景启动器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springboot单元测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 剔除依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打包插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写一个http接口"><a href="#编写一个http接口" class="headerlink" title="编写一个http接口"></a>编写一个http接口</h2><p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p><p>2、在包中新建一个HelloController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZic3WmhvicMATPwQLpTwLtWWE0aQs32iaEKyFnVViacPQbtEdCjBXm5yZf0A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZiczfno2TOQbfItia25xQzicMFnkicKh5pVD7IrHrUicb03y381CicrLFKXNMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如果遇到以上错误，可以配置打包时 跳过项目运行测试用例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    在工作中,很多情况下我们打包是不想执行测试用例的</span></span><br><span class="line"><span class="comment">    可能是测试用例不完事,或是测试用例会影响数据库数据</span></span><br><span class="line"><span class="comment">    跳过测试用例执</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--跳过项目运行测试用例--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果打包成功，则会在target目录下生成一个 jar 包</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZic03vupvIqMbibWh4aIKyjiaQfwuvDWKo033g9kRvj6aXnJO4brKTdwnvA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;狂神说spring-boot第一讲-hello-world&quot;&gt;&lt;a href=&quot;#狂神说spring-boot第一讲-hello-world&quot; class=&quot;headerlink&quot; title=&quot;狂神说spring boot第一讲 hello world&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="spring boot" scheme="http://example.com/categories/spring-boot/"/>
    
    
  </entry>
  
  <entry>
    <title>狂神说SpringBoot02：运行原理初探</title>
    <link href="http://example.com/2023/04/06/%E7%8B%82%E7%A5%9E%E8%AF%B4SpringBoot02%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2023/04/06/%E7%8B%82%E7%A5%9E%E8%AF%B4SpringBoot02%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/</id>
    <published>2023-04-06T04:39:10.000Z</published>
    <updated>2023-04-17T08:25:23.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="狂神说SpringBoot02：运行原理初探"><a href="#狂神说SpringBoot02：运行原理初探" class="headerlink" title="狂神说SpringBoot02：运行原理初探"></a>狂神说SpringBoot02：运行原理初探</h1><p>我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起；</p><p><strong>pom.xml</strong></p><h2 id="父依赖"><a href="#父依赖" class="headerlink" title="父依赖"></a>父依赖</h2><p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.5</span>.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>点进去，发现还有一个父依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p><p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p><h2 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p><p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p><p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义<br>starter；</p><blockquote><p><strong>主启动类</strong></p></blockquote><p>分析完了 pom.xml 来看看这个启动类</p><h2 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">默认的主启动类</span><br><span class="line">    </span><br><span class="line"><span class="comment">//@SpringBootApplication 来标注一个主程序类</span></span><br><span class="line"><span class="comment">//说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//以为是启动了一个方法，没想到启动了一个服务</span></span><br><span class="line">      SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<strong>一个简单的启动类并不简单！</strong>我们来分析一下这些注解都干了什么</p><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><p>进入这个注解：可以看到上面还有很多其他注解！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p><p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p><p>我们继续进去这个注解查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p><p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p><p>我们回到 SpringBootApplication 注解中继续看。</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p><p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p><p>点进注解接续查看：</p><p><strong>@AutoConfigurationPackage ：自动配置包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p><p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p><p>1、这个类中有一个这样的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得候选的配置</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">    <span class="comment">//这里的getSpringFactoriesLoaderFactoryClass（）方法</span></span><br><span class="line">    <span class="comment">//返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="built_in">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="built_in">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> factoryClass.getName();</span><br><span class="line">    <span class="comment">//这里它又调用了 loadSpringFactories 方法</span></span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、我们继续点击查看 loadSpringFactories 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">//获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//去获取一个资源 &quot;META-INF/spring.factories&quot;</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="literal">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            <span class="type">LinkedMultiValueMap</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将读取到的资源遍历，封装成为一个Properties</span></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> (URL)urls.nextElement();</span><br><span class="line">                <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">                <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">var10</span> <span class="operator">=</span> var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">factoryName</span> <span class="operator">=</span> var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p><h2 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h2><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicEIZDCZKtTPxQrKTvEdxHFGsG824OkO8XN8CfP2x4OdpC8DwjHYwcFw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>WebMvcAutoConfiguration</strong></p><p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicaV7UfSRiaRdCHNmHE1wS10QwbLEVZJLB2sN9ztcvjx7n2dKDJ0HrCmA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p><p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure.<br>包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p><p><strong>结论：</strong></p><ol><li>SpringBoot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ol><p><strong>现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！</strong></p><blockquote><p><strong>SpringApplication</strong></p></blockquote><h2 id="不简单的方法"><a href="#不简单的方法" class="headerlink" title="不简单的方法"></a>不简单的方法</h2><p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SpringApplication.run分析</strong></p><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p><h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><p><strong>这个类主要做了以下四件事情：</strong></p><p>1、推断应用的类型是普通的项目还是Web项目</p><p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p><p>3、找出所有的应用程序监听器，设置到listeners属性中</p><p>4、推断并设置main方法的定义类，找到运行的主类</p><p>查看构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="built_in">this</span>.setInitializers(<span class="built_in">this</span>.getSpringFactoriesInstances();</span><br><span class="line">    <span class="built_in">this</span>.setListeners(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = <span class="built_in">this</span>.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1vFQMnaRIJSmeZ58T2eZicjafiawQLp9u8wc4ic1Mjy6OyfibzfjVofeL5pnS1NSFKVjlIg6neI9ySg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;狂神说SpringBoot02：运行原理初探&quot;&gt;&lt;a href=&quot;#狂神说SpringBoot02：运行原理初探&quot; class=&quot;headerlink&quot; title=&quot;狂神说SpringBoot02：运行原理初探&quot;&gt;&lt;/a&gt;狂神说SpringBoot02：运行原理</summary>
      
    
    
    
    <category term="spring" scheme="http://example.com/categories/spring/"/>
    
    
  </entry>
  
</feed>
